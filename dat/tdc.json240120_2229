{
    "cda": {
        " el peso de la respuesta actual": "",
        " entra al calcular la calificaci\u00f3n del usuario a\n   la pregunta que acaba de contestar\n ": "",
        "<div id = nav ><a href = \"#\" id = n2 >": "",
        "salir</a></div></br></br>": "",
        "<div id = cnt ><input id = e0 type = file >": "",
        "</div>": "",
        "</br></br><div id = err ></div>": "",
        "#n2": "",
        "fin": "",
        "e0": "",
        "\t\tpreg_v = [];": "",
        "\t\tleer_a_preg( preg_v, e0.files[0] );": "",
        "function leer_a_preg( preg_v, archivo_x ) {": "",
        "\n\t preg_v.preg\tcadena partida (un arreglo) por valores\n\t \t\"undefined\" donde se meten las soluciones / huecos\n\n\t preg_v.slcn\tlas soluciones, en el orden en el\n\t\tque aparecen en la pregunta\n\n\t preg_v.preg_sin_elim_esc, preg_v.slcn_sin_elim_esc\n\t\tlas preguntas, soluciones sin reducir coincidencias\n\t\tdel car\u00e1cter de escape '\\'\n\t ": "",
        " despu\u00e9s de construir \"preg_v\", prepara la salida\n   de la pregunta siguiente al usuario ": "",
        "#n0": "",
        "beforebegin": "",
        "<a href = \"#\" id = n0 download>guardar</a>": "",
        "&nbsp;": "",
        "<a href = \"#\" id = n1>al inicio</a>": "",
        "#n1": "",
        "#e${ii}": "",
        "\tconsole.log( preg_x.marca);": "",
        " evento mandar respuesta --> al_rsp: actualizar marca -->\n\timprimir pregunta de nuevo\n ": "",
        "#cnt": "",
        "<a href = \"#\" id=\"n3\">seguir</a>": "",
        "#e0": "",
        " pasa tambi\u00e9n \"preg_v\" entero para llevarlo\n\t\ta otras funciones mas adelante: ": "",
        "#n3": "",
        "\";\n\tlet ahtml = {\n\t\t": "",
        ":\t": "",
        ",\n\t\t": "",
        "\":\t": "",
        "\n\t};\n\tfor( ii of preg_con_huecos ) {\n\t\tif( ii == undefined ) rstdo +=\n\t\t\t`<input id = ": "",
        ">`;\n\t\telse rstdo += ii.replace(\n\t\t\t\t/>|<|": "",
        " marca - califica la respuesta \"rsp\" dado la soluci\u00f3n\n   \"slcn\" y el texto de la pregunta\n ": "",
        "\" };\n\trlh_gen( preg_v, rstdo );\n\t// utf-16 a utf-8 hexad\u00e9cimo binario de formato url-datos\n\trstdo.rlh_dat = rstdo.rlh_dat.replace(\n\t\t/.|\\n/g, function ( xx ) {\n    xx = parseInt( xx.charCodeAt(), 10 );\n    if( xx < 0x80 ) return ": "",
        " + xx.toString(16).\n\t\tpadStart(2,0);\n    else if( xx > 0x80 && xx < 0x7FF ) return ": "",
        " +\n        ": "",
        " + ( ( xx >>> 6 ) + 0xC0 ).toString(16).\n\t\t\tpadStart( 2, 0 ) +\n        ": "",
        " + ( xx - (xx >>> 6 << 6) + 0x80 ).toString(16).\n\t\t\tpadStart( 2, 0 );\n    else { console.log(": "",
        "); return 1; }\n\t} );\n\tdocument.querySelector(": "",
        ").setAttribute(": "",
        " + rstdo.rlh_dat);\n}\nfunction err( cda ) {\n\tdocument.querySelector( ": "",
        "---": "",
        "([^\\n\\t ][^\\n]*):": "",
        "\n\t \"rstdo\"\t\"resultado\". Funciones \"as_*\"  analizadores\n\t sintacticos devuelven un numero != 0 al llegar\n\t a una exenci\u00f3n. El resultado del analizador\n\t se guarda en la estructura \"rstdo\" entregado\n\t a la funci\u00f3n.": "",
        "\n\t el exreg del primer marcador del archivo -\n\t llevar\u00e1 adelante solo espacios en blanco\n\t \"[\\t\\n ]\", y termina en un '\\n'. ": "",
        "^[\\n\\t ]*": "",
        "\\n": "",
        "la ficha que delimita las preguntas ": "",
        "no se encontr\u00f3 en el archivo.": "",
        " caso ya no hay mas de marcas (no hay mas preguntas)": "",
        " busca el delimitador final del formato \"rlh\"": "",
        "[^\\n\\t ]{1,}[\\n\\t ]*$": "",
        "no se encontr\u00f3 la ficha del fin ": "",
        "de la lista de preguntas": "",
        "\\\\', ": "",
        " );\n\t/*        caso               \tsignifica\n\n\t \u00edndice devuelto < |ctdo_dat|\t\u00ednd. de cdt\n\n\t    \"     \"     ==      \" - 1\tcdt termina\n\t                             \tla cadena\n\n\t    \"     \"     ==      \"   \tfalta el cdt\n\t */\n\tif( rstdo.nn == ctdo_dat.length - 1 ) {\n\t\terr( \"": "",
        " sin terminar\" );\n\t\treturn 1;\n\t}\n\t// guarda la pregunta hasta el ": "",
        "\n\tif( rstdo.cda ) ctdo_rstdo.preg.push( rstdo.cda );\n\tif( rstdo.sin_elim_esc ) ctdo_rstdo.preg_sin_elim_esc.\n\t\tpush( rstdo.sin_elim_esc );\n\t// caso lleg\u00f3 al fin de la cadena de contenido\n\tif( rstdo.nn == ctdo_dat.length ) return 0;\n\tctdo_dat = ctdo_dat.slice( rstdo.nn + 1 );\n\t// caso anticipar una solici\u00f3n\n\trstdo = {};\n\tleer_hf( ctdo_dat, rstdo, ": "",
        ", ": "",
        " );\n\tif( rstdo.nn == ctdo_dat.length ) {\n\t\terr( \"": "",
        " sin terminar\" );\n\t\treturn 1;\n\t}\n\t// guarda la soluci\u00f3n entre las ": "",
        "\n\tctdo_rstdo.slcn.push( rstdo.cda );\n\tctdo_rstdo.slcn_sin_elim_esc.push( rstdo.sin_elim_esc );\n\t// marca el hueco para la soluci\u00f3n\n\tctdo_rstdo.preg.push(undefined);\n\tctdo_rstdo.preg_sin_elim_esc.push( undefined );\n\tctdo_dat = ctdo_dat.slice( rstdo.nn + 1 );\n\tif( as_ctdo( ctdo_dat, ctdo_rstdo ) ) return 1;\n}\n// leer_hf\tanalizador sint\u00e1ctico de cadenas\n// con car\u00e1cter de escape \"cde\" y car\u00e1cter de\n// terminaci\u00f3n \"cdt\". Actualizar el \u00edndice \"rstdo.nn\"\n// en que termin\u00f3 la funci\u00f3n.\nfunction leer_hf( cda_e, rstdo, cde, cdt ) {\n\tlet ii = 0;\n\trstdo.cda = \"\";\n\trstdo.sin_elim_esc = \"\"; // EVITA PARSE EN FASE GENERAR .RLH\n\tfor( ii = 0; ii < cda_e.length; ii++ ) {\n\t\t// caso: car\u00e1cter de escape\n\t\tif( cda_e[ii] == cde ) {\n\t\t\tif( ++ii == cda_e.length ) break;\n\t\t\trstdo.cda += cda_e[ii];\n\t\t}\n\t\t// caso: ficha de terminaci\u00f3n\n\t\telse if( cda_e[ii] == cdt ) break;\n\t\t// caso: car\u00e1cter no sint\u00e1ctico\n\t\telse rstdo.cda += cda_e[ii];\n\t}\n\trstdo.nn = ii;\n\t// --- GUARDA UNA COPIA SIN QUITAR EL CAR. DE ESC.\n\trstdo.sin_elim_esc = cda_e.slice( 0, ii );\n\treturn 0;\n}\nfunction as_marca( marca_dat, rstdo ) {\n\tif( !marca_dat.match(\n\t\t/^0*[01]$|^0*1[,.]0*$|^0*[,.][0-9]*$/ ) ) {\n\t\terr( \"formato de la marca de pregunta 1\" );\n\t\treturn 1;\n\t}\n\trstdo.marca = parseFloat(\n\t\tmarca_dat.replace( ": "",
        " )  );\n\treturn 0;\n}\nfunction rlh_gen( preg_v, rstdo )\n{\n\tlet xx = 0;\n\tfor( preg_ii of preg_v ) {\n\t\txx = 0;\n\t\trstdo.rlh_dat += ficha0 + preg_ii.marca + \":\\n\";\n\t\tfor( cda_jj of preg_ii.preg_sin_elim_esc ) {\n\t\t\tif( cda_jj == undefined ) rstdo.rlh_dat +=\n\t\t\t\t\"{\" + preg_ii.slcn_sin_elim_esc[xx++] + \"}\";\n\t\t\telse rstdo.rlh_dat += cda_jj;\n\t\t}\n\t\trstdo.rlh_dat += ": "",
        "---fin": ""
    },
    "abrv": {
        "rstdo": "rslt",
        "ant": "prv"
    }
}