{
    "cda": {
        "// el peso de la respuesta actual\n": "",
        "/* entra al calcular la calificaci\u00f3n del usuario a\n   la pregunta que acaba de contestar\n */": "",
        "'<div id = nav ><a href = \"#\" id = n2 >'": "",
        "'salir</a></div></br></br>'": "",
        "'<div id = cnt ><input id = e0 type = file >'": "",
        "'</div>'": "",
        "'</br></br><div id = err ></div>'": "",
        "\"#n2\"": "",
        "\"fin\"": "",
        "\"e0\"": "",
        "//\t\tpreg_v = [];\n": "",
        "//\t\tleer_a_preg( preg_v, e0.files[0] );\n": "",
        "//function leer_a_preg( preg_v, archivo_x ) {\n": "",
        "/*\n\t preg_v.preg\tcadena partida (un arreglo) por valores\n\t \t\"undefined\" donde se meten las soluciones / huecos\n\n\t preg_v.slcn\tlas soluciones, en el orden en el\n\t\tque aparecen en la pregunta\n\n\t preg_v.preg_sin_elim_esc, preg_v.slcn_sin_elim_esc\n\t\tlas preguntas, soluciones sin reducir coincidencias\n\t\tdel car\u00e1cter de escape '\\'\n\t */": "",
        "/* despu\u00e9s de construir \"preg_v\", prepara la salida\n   de la pregunta siguiente al usuario */": "",
        "\"#n0\"": "",
        "\"beforebegin\"": "",
        "'<a href = \"#\" id = n0 download>guardar</a>'": "",
        "\"&nbsp;\"": "",
        "'<a href = \"#\" id = n1>al inicio</a>'": "",
        "\"#n1\"": "",
        "`#e${ii}`": "",
        "//\tconsole.log( preg_x.marca);\n": "",
        "/* evento mandar respuesta --> al_rsp: actualizar marca -->\n\timprimir pregunta de nuevo\n */": "",
        "\"#cnt\"": "",
        "'<a href = \"#\" id=\"n3\">seguir</a>'": "",
        "\"#e0\"": "",
        "/* pasa tambi\u00e9n \"preg_v\" entero para llevarlo\n\t\ta otras funciones mas adelante: */": "",
        "\"#n3\"": "",
        "\"\"": "",
        "\"&\"": "",
        "\"&amp;\"": "",
        "\"<\"": "",
        "\"&lt;\"": "",
        "\">\"": "",
        "\"&gt;\"": "",
        "\"\\\"\"": "",
        "\"&quot;\"": "",
        "\"\\n\"": "",
        "\"<br>\"": "",
        "\" \"": "",
        "`<input id = \"e${xx++}\">`": "",
        "\"|&|\\n| /g,\n\t\t\t\tfunction(cc) { return ahtml[cc]; } );\n\t}\n\treturn rstdo;\n}\nfunction escoger_preg( preg_v ) {\n\tlet pregv_marca = [];\n\tfor( ii of preg_v ) pregv_marca.push( ii.marca );\n\treturn pregv_marca.indexOf(  Math.min(\n\t\t...pregv_marca )  );\n}\n/* marca - califica la respuesta \"": "",
        "\" dado la soluci\u00f3n\n   \"": "",
        "\" y el texto de la pregunta\n */\nfunction marca( rsp, slcn, texto ) {\n\tlet marca_x = 0;\n\tfor( ii in slcn )\n\t\tif( slcn[ ii ] == rsp[ ii ] )\n\t\t\tmarca_x++;\n\treturn marca_x / slcn.length;\n}\nfunction marca_preg_sum( val, delta ) {\n\t\treturn (1 - theta) * val + theta * delta;\n}\nfunction n0_href( preg_v ) {\n\tlet rstdo = { rlh_dat: \"": "",
        "\" };\n\trlh_gen( preg_v, rstdo );\n\t// utf-16 a utf-8 hexad\u00e9cimo binario de formato url-datos\n\trstdo.rlh_dat = rstdo.rlh_dat.replace(\n\t\t/.|\\n/g, function ( xx ) {\n    xx = parseInt( xx.charCodeAt(), 10 );\n    if( xx < 0x80 ) return \"": "",
        "\" + xx.toString(16).\n\t\tpadStart(2,0);\n    else if( xx > 0x80 && xx < 0x7FF ) return \"": "",
        "\" +\n        \"": "",
        "\" + ( ( xx >>> 6 ) + 0xC0 ).toString(16).\n\t\t\tpadStart( 2, 0 ) +\n        \"": "",
        "\" + ( xx - (xx >>> 6 << 6) + 0x80 ).toString(16).\n\t\t\tpadStart( 2, 0 );\n    else { console.log(\"": "",
        "\"); return 1; }\n\t} );\n\tdocument.querySelector(\"": "",
        "\").setAttribute(\"": "",
        "\",\n\t\t\"": "",
        "\" + rstdo.rlh_dat);\n}\nfunction err( cda ) {\n\tdocument.querySelector( \"": "",
        "\"---\"": "",
        "\"([^\\n\\t ][^\\n]*):\"": "",
        "/*\n\t \"rstdo\"\t\"resultado\". Funciones \"as_*\"  analizadores\n\t sintacticos devuelven un numero != 0 al llegar\n\t a una exenci\u00f3n. El resultado del analizador\n\t se guarda en la estructura \"rstdo\" entregado\n\t a la funci\u00f3n.*/": "",
        "/*\n\t el exreg del primer marcador del archivo -\n\t llevar\u00e1 adelante solo espacios en blanco\n\t \"[\\t\\n ]\", y termina en un '\\n'. */": "",
        "\"^[\\n\\t ]*\"": "",
        "'\\n'": "",
        "\"la ficha que delimita las preguntas \"": "",
        "\"no se encontr\u00f3 en el archivo.\"": "",
        "// caso ya no hay mas de marcas (no hay mas preguntas)\n": "",
        "// busca el delimitador final del formato \"rlh\"\n": "",
        "\"[^\\n\\t ]{1,}[\\n\\t ]*$\"": "",
        "\"no se encontr\u00f3 la ficha del fin \"": "",
        "\"de la lista de preguntas\"": "",
        "'\\\\'": "",
        "'{'": "",
        "/*        caso               \tsignifica\n\n\t \u00edndice devuelto < |ctdo_dat|\t\u00ednd. de cdt\n\n\t    \"     \"     ==      \" - 1\tcdt termina\n\t                             \tla cadena\n\n\t    \"     \"     ==      \"   \tfalta el cdt\n\t */": "",
        "\"'{' sin terminar\"": "",
        "// guarda la pregunta hasta el '{'\n": "",
        "// caso lleg\u00f3 al fin de la cadena de contenido\n": "",
        "// caso anticipar una solici\u00f3n\n": "",
        "'}'": "",
        "// guarda la soluci\u00f3n entre las '{', '}'\n": "",
        "// marca el hueco para la soluci\u00f3n\n": "",
        "// leer_hf\tanalizador sint\u00e1ctico de cadenas\n": "",
        "// con car\u00e1cter de escape \"cde\" y car\u00e1cter de\n": "",
        "// terminaci\u00f3n \"cdt\". Actualizar el \u00edndice \"rstdo.nn\"\n": "",
        "// en que termin\u00f3 la funci\u00f3n.\n": "",
        "// EVITA PARSE EN FASE GENERAR .RLH\n": "",
        "// caso: car\u00e1cter de escape\n": "",
        "// caso: ficha de terminaci\u00f3n\n": "",
        "// caso: car\u00e1cter no sint\u00e1ctico\n": "",
        "// --- GUARDA UNA COPIA SIN QUITAR EL CAR. DE ESC.\n": "",
        "\"formato de la marca de pregunta 1\"": "",
        "','": "",
        "'.'": "",
        "\":\\n\"": "",
        "\"{\"": "",
        "\"}\"": "",
        "\"---fin\"": ""
    },
    "abrv": {
        "rstdo": "rslt",
        "ant": "prv"
    }
}