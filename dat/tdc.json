{
    "cda":
{
        " el peso de la respuesta actual":
" the current weight of the response",

        " entra al calcular la calificación del usuario a\n   la pregunta que acaba de contestar\n ":
"enters when to calculate the points of the user to\n    the question that was now answered\n ",

        "<div id = nav ><a href = \"#\" id = n2 >":
"",

        "salir</a></div></br></br>":
"exit</a></div></br></br>",

        "<div id = cnt ><input id = e0 type = file >":
"",

        "</div>":
"",

        "</br></br><div id = err ></div>":
"",

        "#n2":
"",

        "fin":
"",

        "e0":
"",

        "\t\tpreg_v = [];":
"",

        "\t\tleer_a_preg( preg_v, e0.files[0] );":
"",

        "function leer_a_preg( preg_v, archivo_x ) {":
"",

        "\n\t preg_v.preg\tcadena partida (un arreglo) por valores\n\t \t\"undefined\" donde se meten las soluciones / huecos\n\n\t preg_v.slcn\tlas soluciones, en el orden en el\n\t\tque aparecen en la pregunta\n\n\t preg_v.preg_sin_elim_esc, preg_v.slcn_sin_elim_esc\n\t\tlas preguntas, soluciones sin reducir coincidencias\n\t\tdel carácter de escape '\\'\n\t ":
"\n\t preg_v.preg\tdivided string (an array) of values\n\t \t\"undefined\" where the solutions / holes\n\n\t preg_v.slcn\tthe solutions, in the order that\n\tthey appearin the question\n\n\t preg_v.preg_sin_elim_esc, preg_v.slcn_sin_elim_esc\n\t\tthe questions, solutions without to reduce matches\n\t\tof the escape character '\\'\n\t ",

        " después de construir \"preg_v\", prepara la salida\n   de la pregunta siguiente al usuario ":
" after to construc \"preg_v\", prepare the output\n   of the next question to the user ",

        "#n0":
"",

        "beforebegin":
"",

        "<a href = \"#\" id = n0 download>guardar</a>":
"<a href = \"#\" id = n0 download>save</a>",

        "&nbsp;":
"",

        "<a href = \"#\" id = n1>al inicio</a>":
"<a href = \"#\" id = n1>to the start</a>",

        "#n1":
"",

        "#e${ii}":
"",

        " evento mandar respuesta --> al_rsp: actualizar marca -->\n\timprimir pregunta de nuevo\n ":
" event send response --> al_rsp: update the points -->\n\tprint question from new",

        "#cnt":
"",

        "<a href = # id = n3>seguir</a>":

       "<a href = # id = n3>continue</a>",

        "#e0":
"",

        " pasa también \"preg_v\" entero para llevarlo\n\t\ta otras funciones mas adelante: ":
" pass also \"preg_v\" complete to take it\n\tto other functions later: ",

        "#n3":
"",

        "beforeend":
"",

        "<p>marca: ${Math.floor(marca_x * 100)}%</p>":
        "<p>score: ${Math.floor(marca_x * 100)}%</p>",

        "<a href = # id = n4>a la solución</a>":
        "<a href = # id = n4>to the solution</a>",

        "input":
"",

        "readonly":
"",

        "intentarlo de nuevo":
"redo",

        "#n4":
"",

        "\"${ii}\", ":
"",

        "<p>${slcn}</p>":
"",

        " si se enseña la solución, agrega otro 0 puntos":
" if the solution is shown, add another 0 points",

        ">|<|\\\"|\\n| ":
"",

        "g":
"",

        "&":
"",

        "&amp;":
"",

        "<":
"",

        "&lt;":
"",

        ">":
"",

        "&gt;":
"",

        "\\\"":
"",

        "&quot;":
"",

        "\\n":
"",

        "<br>":
"",

        " ":
"",

        "<input id = \"e${xx++}\">":
"",

        "\t\t\t\tcambio al sintaxis \"new RegExp\"":
"\t\t\t\tchange of syntax \"new RegExp\"",

        "\t\t\t\tpor un limite de un analizador sintactico":
"\t\t\t\tbecause of a limit of the parser",

        "\t\t\t\tde traducción":
"\t\t\t\tof the translation",

        "\t\t\t\t/>|<|\"|&|\\n| /g,":
"",

        " marca - califica la respuesta \"rsp\" dado la solución\n   \"slcn\" y el texto de la pregunta\n ":
" marca - gives points to the responce \"rsp\" given the solution\n   \"slcn\" and the text of the question\n ",

        " utf-16 a utf-8 hexadécimo binario de formato url-datos":
" utf-16 to utf-8 hexadecimal of the data-url",

        "%":
"",

        "carácter desconocido":
"unrecognized character",

        "href":
"",

        "data:text/plain;charset=UTF-8,":
"",

        "#err":
"",

        "---":
"",

        "([^\\n\\t ][^\\n]*):":
"",

        "\n\t \"rstdo\"\t\"resultado\". Funciones \"as_*\"  analizadores\n\t sintacticos devuelven un numero != 0 al llegar\n\t a una exención. El resultado del analizador\n\t se guarda en la estructura \"rstdo\" entregado\n\t a la función.":
"\n\t \"rstdo\"\t\"result\". Functions \"as_*\" analyzers\n\t of syntax return a number != 0 to arrive\n\t at an error. The result of the analyzer\n\t is saved in the structure \"rstdo\"\t given\n\t to the function.",

        "\n\t el exreg del primer marcador del archivo -\n\t llevará adelante solo espacios en blanco\n\t \"[\\t\\n ]\", y termina en un '\\n'. ":
"\n\t the regex of the first marker of the file -\n\t will take in front only empty spaces\n\t \"[\\t\\n ]\", and terminate in a '\\n'. ",

        "^[\\n\\t ]*":
"",

        "la ficha que delimita las preguntas ":
"the token that delimits the questions ",

        "no se encontró en el archivo.":
"file not encountered.",

        " caso ya no hay mas de marcas (no hay mas preguntas)":
" case no more delimiters (no questions remain)",

        " busca el delimitador final del formato \"rlh\"":
" search the final delimiter fo the \"rlh\" format",

        "[^\\n\\t ]{1,}[\\n\\t ]*$":
"",

        "no se encontró la ficha del fin ":
"end token not encountered ",

        "de la lista de preguntas":
"of the list of questions",

        "\\\\":
"",

        "{":
"",

        "        caso               \tsignifica\n\n\t índice devuelto < |ctdo_dat|\tínd. de cdt\n\n\t    \"     \"     ==      \" - 1\tcdt termina\n\t                             \tla cadena\n\n\t    \"     \"     ==      \"   \tfalta el cdt\n\t ":
"        case               \tsignifies\n\n\t index returned < |ctdo_dat|\tind. of cdt\n\n\t     \"      \"    ==      \" - 1\tcdt ends\n\t                                \tthe string\n\n\t    \"    \"     ==       \"   \tmissing the string\n\t",

        "'{' sin terminar":
"'{' not completed",

        " guarda la pregunta hasta el '{'":
" save the question until the '{'",

        " caso llegó al fin de la cadena de contenido":
" case arrived at the end of the string of content",

        " caso anticipar una solición":
" case expect a solution",

        "}":
"",

        " guarda la solución entre las '{', '}'":
" save the solution between '{', '}'",

        " marca el hueco para la solución":
" mark the hole to be solved",

        " leer_hf\tanalizador sintáctico de cadenas":
" leer_ht\t parser of strings",

        " con carácter de escape \"cde\" y carácter de":
" with character of escape \"cde\" and character of",

        " terminación \"cdt\". Actualizar el índice \"rstdo.nn\"":
" termination \"cdt\". Update teh index \"rstdo.nn\"",

        " en que terminó la función.":
" in that the function terminated.",

        " EVITA PARSE EN FASE GENERAR .RLH":
" PREVENT PARSE IN PHASE GENERATE .RLH",

        " caso: carácter de escape":
" case: escape character",

        " caso: ficha de terminación":
" case: token of end",

        " caso: carácter no sintáctico":
" case: not syntactic character",

        " --- GUARDA UNA COPIA SIN QUITAR EL CAR. DE ESC.":
" --- SAVE A COPY BUT DO NOT REMOVE ESC. CHAR.",

        "formato de la marca de pregunta 1":
"format of the marker of question 1",

        ",":
"",

        ".":
"",

        ":\\n":
"",

        "---fin":
"---end"
    },

    "abrv":
{
        "rstdo":
"rslt",

        "bucle":
"loop",

        "preg":
"qstn",

        "leer_":
"read_",

        "archivo":
"file",

        "ach_lector":
"reader",

        "marca":
"points",

        "impr_":
"prt_",

        "huecos":
"holes",

        "escoger":
"choose",

        "slcn":
"sln",

        "_sg":
"_suc",

        "sin_":
"no_",

        "ctdo":
"ctnt",

        "cda":
"str",

        "_hf":
"to_tok",

        "rll":
"cllb"

    }
}
